
# 函数式编程

函数式编程就是对运算过程的抽象，其中的函数是指数学中的函数即映射关系，相同的输入始终要得到相同的输出（纯函数）。


### 函数是一等公民
- 函数可以存储在变量中
- 函数作为参数
- 函数作为返回值

函数是一等公民是我们后面要学习的高阶函数、柯里化等的基础

使用高阶函数的意义：
- 抽象可以帮我们屏蔽细节，只需要关注于我们的目标
- 高阶函数是用来抽象通用的问题


### 闭包
可以在另一个作用域中调用一个函数的内部函数并访问到该函数作用域中的成员

闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。


### 纯函数
相同的输入永远会得到相同的输出，而且没有任务可观察的副作用。

纯函数的好处：
- 可缓存，纯函数对相同的输入始终有相同的结果，所以可以吧结果缓存起来
- 可测试，纯函数让测试更方便
- 并行处理，纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数


### 副作用
副作用让一个函数变得不纯，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。

副作用来源：
- 全局变量
- 配置文件
- 数据库
- 获取用户的输入
- ...


### 柯里化（Currying）
- 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
- 然后返回一个新的函数接收剩余的参数，返回结果

总结：
- 柯里化可以让我们给一个函数传递较少的参数，得到一个已经记住了某些固定参数的新函数
- 这是一种对函数参数的“缓存”
- 让函数变得更加灵活，让函数的粒度更小
- 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能


### 函数组合
函数组合（compose）：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数
- 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果
- 通过函数组合可以把多个一元函数组合成一个功能更强大的函数
- 函数组合默认是从右到左执行
- 函数组合需要满足结合律

函数组合要满足**结合律**(associativity)

我们既可以把 g 和 h 组合，还可以把 f 和 g 组合，结果都是一样的

```javascript
let f = compose(f, g, h)
let associative = compose(compose(f, g), h) == compose(f, compose(g, h));
// true
```

### lodash/fp
- lodash 的 fp 模块提供了实用的对 **函数式编程友好** 的方法
- 提供了不可变 **auto-curried , iteratee-first, data-last** 的方法


### PointFree

我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。

- 不需要指明处理的数据
- 只需要合成运算过程
- 需要定义一些辅助的基本运算函数


### Functor(函子)

什么是函子？
- 容器：包含值和值的变形关系（这个变形关系就是函数）
- 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理（变形关系）

MayBe 函子
- 我们在编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理
- Maybe 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）

Either 函子
- Either 两者中的任何一个，类似于 if...else... 的处理
- 异常会让函数变的不纯，Either 函子可以用来做异常处理

IO 函子
- IO 函子中的 _value 是一个函数，这里是把函数作为值来处理
- IO 函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作（惰性执行）
- 包装当前的操作，把不纯的操作交给调用者来处理

folktale
- 一个标准的函数式编程库
- 和 lodash、ramda 不同的是，他没有提供很多功能函数
- 只提供了一些函数式处理的操作，例如：compose、curry 等，一些函子 Task,Either,MayBe 等
- task 异步执行

Pointed 函子
- Pointed 函子是实现了 of 静态方法的函子
- of 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文 Context 中（把值放到容器中，使用 map 来处理值）

Monad 函子
- Monad 函子是可以变扁的 Pointed 函子，IO(IO(x))
- 一个函子如果具有 join 和 of 两个方法，并遵守一些定律就是一个 Monad

